// @ts-nocheck
import fs from 'fs';
import path from 'path';

// Configuration
const PUBLIC_DIR = path.join(process.cwd(), 'public');
const OUTPUT_FILE = path.join(process.cwd(), 'src/utils/cache/staticAssetList.ts');

// File extensions to include
const ASSET_EXTENSIONS = ['.svg', '.png', '.jpg', '.jpeg', '.gif', '.ico', '.webp', '.webmanifest'];

// Additional directories to include all files from (relative to public)
const INCLUDE_ALL_FROM_DIRS = ['icons'];

// Specific paths to always include
const ALWAYS_INCLUDE = [
    '/',
    '/books',
    '/offline',
    '/cache',
    '/manifest.webmanifest',
    '/web-app-manifest-192x192.png',
    '/web-app-manifest-512x512.png',
];

// File/directory patterns to exclude
const EXCLUDE_PATTERNS = [
    '.DS_Store',
    'books/addDateToFrontMatter.js',
    'books/generateBookList.js',
];

// Function to check if a file should be included based on extension
function shouldIncludeFile(filePath) {
    const ext = path.extname(filePath).toLowerCase();
    return ASSET_EXTENSIONS.includes(ext);
}

// Function to check if a path should be excluded
function shouldExcludePath(relativePath) {
    return EXCLUDE_PATTERNS.some(pattern => relativePath.includes(pattern));
}

// Function to recursively find all assets in a directory
function findAssetsInDir(dir, baseDir = PUBLIC_DIR, assets = []) {
    const entries = fs.readdirSync(dir, { withFileTypes: true });

    for (const entry of entries) {
        const fullPath = path.join(dir, entry.name);
        const relativePath = path.relative(baseDir, fullPath);

        if (shouldExcludePath(relativePath)) {
            continue;
        }

        if (entry.isDirectory()) {
            findAssetsInDir(fullPath, baseDir, assets);
        } else if (entry.isFile()) {
            // Always include files from specified directories
            const parentDir = path.relative(baseDir, dir).split(path.sep)[0];
            const shouldAlwaysInclude = INCLUDE_ALL_FROM_DIRS.includes(parentDir);

            if (shouldAlwaysInclude || shouldIncludeFile(entry.name)) {
                const assetPath = '/' + relativePath.replace(/\\/g, '/');
                assets.push(assetPath);
            }
        }
    }

    return assets;
}

// Main function
function generateAssetList() {
    console.log('Generating static asset list...');

    // Find all assets
    let assets = [...ALWAYS_INCLUDE];
    assets = assets.concat(findAssetsInDir(PUBLIC_DIR));

    // Remove duplicates
    assets = [...new Set(assets)];

    // Sort for readability
    assets.sort();

    // Generate TypeScript file content
    const fileContent = `// This file is auto-generated by scripts/generateAssetList.js
// DO NOT EDIT MANUALLY

/**
 * List of static assets to be cached by the service worker
 */
export const STATIC_ASSETS = ${JSON.stringify(assets, null, 4)};

/**
 * Common SVG assets that are frequently used
 */
export const COMMON_SVG_ASSETS = ${JSON.stringify(
        assets.filter(asset => asset.endsWith('.svg')),
        null,
        4,
    )};

/**
 * Images and icons to pre-cache
 */
export const IMAGE_ASSETS = ${JSON.stringify(
        assets.filter(
            asset =>
                asset.endsWith('.png') ||
                asset.endsWith('.jpg') ||
                asset.endsWith('.jpeg') ||
                asset.endsWith('.gif') ||
                asset.endsWith('.webp'),
        ),
        null,
        4,
    )};
`;

    // Write to file
    fs.writeFileSync(OUTPUT_FILE, fileContent);

    console.log(`Generated asset list with ${assets.length} files`);
    console.log(`SVGs: ${assets.filter(a => a.endsWith('.svg')).length}`);
    console.log(
        `Images: ${
            assets.filter(
                a =>
                    a.endsWith('.png') ||
                    a.endsWith('.jpg') ||
                    a.endsWith('.jpeg') ||
                    a.endsWith('.gif') ||
                    a.endsWith('.webp'),
            ).length
        }`,
    );
    console.log(`Output written to: ${OUTPUT_FILE}`);
}

// Run the generator
generateAssetList();
